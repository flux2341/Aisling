<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Aisling</title>
    
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="modules.js"></script>
  </head>
  <body>

    <div id="div_alert_background" style="display:none">
        <div id="div_alert_box">
            <span id="div_alert_text"></span>
            <div id="div_alert_buttons">
                <div id="div_alert_bt_ok">ok</div>
                <div id="div_alert_bt_cancel">cancel</div>
            </div>
        </div>
    </div>
    
    <div id="div_entries" class="split scrollable">
        <ul id="ul_entries">
        </ul>
    </div>
    <div id="div_detail" class="split">
        <div id="div_view_bts" class="top_bts">
            <div id="bt_new">new</div>
            <div id="bt_edit">edit</div>
        </div>
        <div id="div_edit_bts" class="top_bts" style="display:none">
            <div id="bt_delete">delete</div>
            <div id="bt_save">save</div>
            <div id="bt_cancel">cancel</div>
        </div>
    </div>

    
    <script>
        

        const storage = require('electron-json-storage');

        let ul_entries = document.querySelector('#ul_entries');
        let div_detail = document.querySelector('#div_detail');

        let div_view_bts = document.querySelector('#div_view_bts');
        let div_edit_bts = document.querySelector('#div_edit_bts');

        let module_names = ['word', 'definition'];
        let modules = []


        var Split = require('split.js');
        Split(['#div_entries', '#div_detail'], {
            sizes: [20, 80],
            gutterSize: 20,
            minSize: [5, 5],
            direction: 'horizontal',
            cursor: 'col-resize',
            snapOffset: 0
        });
        
        // if path is null, just re-use the existing path
        function load_from_storage(path, word) {
            if (path !== null) {
                storage.setDataPath(path);
            }
            storage.keys(function(error, keys) {
                if (error) {
                    console.log(error);
                } else {
                    // clear existing li's
                    while (ul_entries.hasChildNodes()) {
                        ul_entries.removeChild(ul_entries.lastChild);
                    }

                    // add new li's from the data
                    for (let key in keys) {
                        add_word(keys[key]);
                    }
                }
                if (word) {
                    pick_word(word);
                } else {
                    view_entry(null);
                }
            });
        }


        // create detail page from modules
        for (let i=0; i<module_names.length; ++i) {
            let container = document.createElement('div');
            container.style.width = "100%";
            let module = null;
            if (module_names[i] === 'word') {
                module = new ModuleWord(container);
            } else if (module_names[i] === 'definition') {
                module = new ModuleDefinition(container);
            } else {
                console.error('unrecognized module "'+module_names[i]+'"');
                continue;
            }
            modules.push(module);
            div_detail.appendChild(container);
        }

        let current_entry = null;
        function view_entry(entry) {
            current_entry = entry;
            for (let i=0; i<modules.length; ++i) {
                modules[i].switch_to_view_mode(entry);
            }
            div_view_bts.style.display = 'block';
            div_edit_bts.style.display = 'none';
        }

        function edit_entry(entry) {
            current_entry = entry;
            for (let i=0; i<modules.length; ++i) {
                modules[i].switch_to_edit_mode(current_entry);
            }
            div_view_bts.style.display = 'none';
            div_edit_bts.style.display = 'block';
        }

        function pick_word(word) {

            

            //  update the list of entries
            for (let i=0; i<ul_entries.children.length; ++i) {
                let c = ul_entries.children[i];
                if (c.innerText === word) {
                    c.style.color = 'white';
                    c.setAttribute('selected', 'selected');
                } else if (c.hasAttribute('selected')) {
                    c.style.color = null;
                    c.removeAttribute('selected');
                }
            }
            
            // get the word from storage
            storage.get(word, function(error, entry) {
                if (error) {
                    console.log(error)
                } else {
                    view_entry(entry);
                }
            });
        }
        

        // add an word to the list of words
        function add_word(word) {
            let li = document.createElement('li');
            li.innerText = word;
            li.onclick = function() {
                pick_word(word);
            }
            ul_entries.appendChild(li);
        }


        



        let bt_new = document.querySelector('#bt_new');
        let bt_edit = document.querySelector('#bt_edit');
        let bt_delete = document.querySelector('#bt_delete');
        let bt_save = document.querySelector('#bt_save');
        let bt_cancel = document.querySelector('#bt_cancel');


        bt_new.onclick = function() {
            for (let i=0; i<ul_entries.children.length; ++i) {
                let c = ul_entries.children[i];
                if (c.hasAttribute('selected')) {
                    c.style.color = null;
                    c.removeAttribute('selected');
                }
            }
            edit_entry(null);
        }

        bt_edit.onclick = function() {
            edit_entry(current_entry);
        }

        bt_save.onclick = function() {
            
            let old_word = null;
            if (current_entry !== null) {
                old_word = current_entry.word;
            }
            let temp_entry = {};
            for (let i=0; i<modules.length; ++i) {
                modules[i].save(temp_entry); // copy data from input fields into the new or existing entry
            }

            // check if the input word is blank
            if (temp_entry.word === '') {
                show_alert({
                    message: 'the word cannot be blank',
                    buttons: ['ok', 'cancel'],
                    callback: function(response) {}
                });
                return;
            }

            //  check if the input word already exists
            if (old_word !== temp_entry.word) {
                for (let i=0; i<ul_entries.children.length; ++i) {
                    let word = ul_entries.children[i].innerText;
                    if (word === temp_entry.word) {
                        alert('the entry\'s word must be unique');
                        return;
                    }
                }
            }

            // save the new word
            current_entry = temp_entry;
            storage.set(current_entry.word, current_entry, function(error) {
                if (error) {
                    console.log(error);
                }
                // if we made a new word or changed the existing one
                if (old_word !== current_entry.word) {
                    if (old_word !== null) {

                        // if the name's been updated, remove the old one
                        storage.remove(old_word, function(error) {
                            if (error) {
                                console.log(error);
                            }
                            load_from_storage(null, current_entry.word); // inefficient, but I don't want to bother sorting
                        });
                    } else {
                        load_from_storage(null, current_entry.word); // inefficient, but I don't want to bother sorting
                    }
                    
                } else {
                    pick_word(current_entry.word);
                }
            });
            

        }

        bt_cancel.onclick = function() {
            view_entry(current_entry);
        }

        bt_delete.onclick = function() {
            if (current_entry) {
                storage.remove(current_entry.word, function(error) {
                    if (error) {
                        console.log(error);
                    }
                    load_from_storage(null); // inefficient, but I don't want to bother sorting
                });
            } else {
                view_entry(null);
            }
        }


        
        let db_path = 'C:\\Users\\flux\\data\\aisling';
        load_from_storage(db_path);
        view_entry(null);

        // store settings somewhere else
        // settings - db location, search text, last word

        let div_alert_background = document.querySelector('#div_alert_background');
        let div_alert_text = document.querySelector('#div_alert_text');

        function show_alert(obj) {
            div_alert_text.innerText = obj.message;
            let buttons = {
                ok: document.querySelector('#div_alert_bt_ok'),
                cancel: document.querySelector('#div_alert_bt_cancel')
            }
            for (button_name in buttons) {
                if (obj.buttons.indexOf(button_name) >= 0) {
                    buttons[button_name].style.display = 'inline-block';
                    buttons[button_name].button_name = button_name;
                    buttons[button_name].onclick = function() {
                        div_alert_background.style.display = 'none';
                        obj.callback(this.button_name);
                    }
                } else {
                    buttons[button_name].style.display = 'none';
                }
            }
            div_alert_background.style.display = 'block';
        }

    </script>

  </body>
</html>
