<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <title>Aisling</title>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="modules.js"></script>
    </head>
    <body>

        <div id="div_alert_background" style="display:none">
            <div id="div_alert_box">
                <span id="div_alert_text"></span>
                <div id="div_alert_buttons">
                </div>
            </div>
        </div>

        <div id="div_entries" class="split scrollable">
            <input type="text" id="input_search"/>
            <ul id="ul_entries">
            </ul>
        </div>
        <div id="div_detail" class="split">
            <div id="div_view_bts" class="top_bts">
                <div id="bt_new">new</div>
                <div id="bt_edit">edit</div>
            </div>
            <div id="div_edit_bts" class="top_bts" style="display:none">
                <div id="bt_delete">delete</div>
                <div id="bt_save">save</div>
                <div id="bt_cancel">cancel</div>
            </div>
        </div>

        <script>
            

            const storage = require('electron-json-storage');
            const settings = require('electron-settings');
            const {dialog} = require('electron').remote;

            //settings.deleteAll();
            if (!settings.has('storage_path')) {
                let result = dialog.showOpenDialog({properties: ['openDirectory']});
                settings.set('storage_path', result[0]);
            }

            let storage_path = settings.get('storage_path');
            let last_search_text = settings.get('last_search_text');
            let last_selected_word = settings.get('last_selected_word');
            
            let input_search = document.querySelector('#input_search');
            let ul_entries = document.querySelector('#ul_entries');
            let div_detail = document.querySelector('#div_detail');

            let div_view_bts = document.querySelector('#div_view_bts');
            let div_edit_bts = document.querySelector('#div_edit_bts');

            let module_names = ['word', 'definition'];
            let modules = []


            var Split = require('split.js');
            Split(['#div_entries', '#div_detail'], {
                sizes: [20, 80],
                gutterSize: 20,
                minSize: [5, 5],
                direction: 'horizontal',
                cursor: 'col-resize',
                snapOffset: 0
            });
            
            // if path is null, just re-use the existing path
            function load_from_storage(path, word) {
                if (path !== null) {
                    storage.setDataPath(path);
                }
                storage.keys(function(error, keys) {
                    if (error) {
                        console.log(error);
                    } else {
                        // clear existing li's
                        clear_children(ul_entries);

                        // add new li's from the data
                        for (let key in keys) {
                            add_word(keys[key]);
                        }
                    }
                    if (word) {
                        pick_word(word);
                    } else {
                        view_entry(null);
                    }
                });
            }


            // create detail page from modules
            for (let i=0; i<module_names.length; ++i) {
                let container = document.createElement('div');
                container.style.width = "100%";
                let module = null;
                if (module_names[i] === 'word') {
                    module = new ModuleWord(container);
                } else if (module_names[i] === 'definition') {
                    module = new ModuleDefinition(container);
                } else {
                    console.error('unrecognized module "'+module_names[i]+'"');
                    continue;
                }
                modules.push(module);
                div_detail.appendChild(container);
            }

            let current_entry = null;
            function view_entry(entry) {
                current_entry = entry;
                for (let i=0; i<modules.length; ++i) {
                    modules[i].switch_to_view_mode(entry);
                }
                div_view_bts.style.display = 'block';
                div_edit_bts.style.display = 'none';
            }

            function edit_entry(entry) {
                current_entry = entry;
                for (let i=0; i<modules.length; ++i) {
                    modules[i].switch_to_edit_mode(current_entry);
                }
                div_view_bts.style.display = 'none';
                div_edit_bts.style.display = 'block';
            }

            function pick_word(word) {

                //  update the list of entries
                for (let i=0; i<ul_entries.children.length; ++i) {
                    let c = ul_entries.children[i];
                    if (c.innerText === word) {
                        c.style.color = 'white';
                        c.setAttribute('selected', 'selected');
                    } else if (c.hasAttribute('selected')) {
                        c.style.color = null;
                        c.removeAttribute('selected');
                    }
                }

                if (word) {
                    // get the word from storage
                    storage.get(word, function(error, entry) {
                        if (error) {
                            console.log(error)
                        } else {
                            view_entry(entry);
                        }
                    });
                } else {
                    view_entry(null);
                }
            }
            

            // add an word to the list of words
            function add_word(word) {
                let li = document.createElement('li');
                li.innerText = word;
                li.onclick = function() {
                    pick_word(word);
                }
                ul_entries.appendChild(li);
            }


            let bt_new = document.querySelector('#bt_new');
            let bt_edit = document.querySelector('#bt_edit');
            let bt_delete = document.querySelector('#bt_delete');
            let bt_save = document.querySelector('#bt_save');
            let bt_cancel = document.querySelector('#bt_cancel');


            bt_new.onclick = function() {
                for (let i=0; i<ul_entries.children.length; ++i) {
                    let c = ul_entries.children[i];
                    if (c.hasAttribute('selected')) {
                        c.style.color = null;
                        c.removeAttribute('selected');
                    }
                }
                edit_entry(null);
            }

            bt_edit.onclick = function() {
                edit_entry(current_entry);
            }

            bt_save.onclick = function() {
                
                let old_word = null;
                if (current_entry !== null) {
                    old_word = current_entry.word;
                }
                let temp_entry = {};
                for (let i=0; i<modules.length; ++i) {
                    modules[i].save(temp_entry); // copy data from input fields into the new or existing entry
                }

                // check if the input word is blank
                if (temp_entry.word === '') {
                    show_alert({
                        message: 'the word cannot be blank',
                        buttons: ['ok'],
                        callback: function(response) {}
                    });
                    return;
                }

                //  check if the input word already exists
                if (old_word !== temp_entry.word) {
                    for (let i=0; i<ul_entries.children.length; ++i) {
                        let word = ul_entries.children[i].innerText;
                        if (word === temp_entry.word) {
                            show_alert({
                                message: 'the word must be unique',
                                buttons: ['ok'],
                                callback: function(response) {}
                            });
                            return;
                        }
                    }
                }

                // save the new word
                current_entry = temp_entry;
                storage.set(current_entry.word, current_entry, function(error) {
                    if (error) {
                        console.log(error);
                    }
                    // if we made a new word or changed the existing one
                    if (old_word !== current_entry.word) {
                        if (old_word !== null) {

                            // if the name's been updated, remove the old one
                            storage.remove(old_word, function(error) {
                                if (error) {
                                    console.log(error);
                                }
                                load_from_storage(null, current_entry.word); // inefficient, but I don't want to bother sorting
                            });
                        } else {
                            load_from_storage(null, current_entry.word); // inefficient, but I don't want to bother sorting
                        }
                        
                    } else {
                        pick_word(current_entry.word);
                    }
                });
                

            }

            bt_cancel.onclick = function() {
                view_entry(current_entry);
            }

            bt_delete.onclick = function() {
                show_alert({
                    message: 'are you sure?',
                    buttons: ['yes', 'no'],
                    callback: function(response) {
                        if (response === 'yes') {
                            if (current_entry) {
                                storage.remove(current_entry.word, function(error) {
                                    if (error) {
                                        console.log(error);
                                    }
                                    load_from_storage(null); // inefficient, but I don't want to bother sorting
                                });
                            } else {
                                view_entry(null);
                            }
                        }
                    }
                });
            }



            function show_alert(obj) {

                let div_alert_background = document.querySelector('#div_alert_background');
                let div_alert_text = document.querySelector('#div_alert_text');
                let div_alert_buttons = document.querySelector('#div_alert_buttons');

                div_alert_text.innerText = obj.message;
                clear_children(div_alert_buttons);
                for (let i=0; i<obj.buttons.length; ++i) {
                    let div_bt = document.createElement('div');
                    div_bt.innerText = obj.buttons[i];
                    div_bt.onclick = function() {
                        div_alert_background.style.display = 'none';
                        obj.callback(this.innerText);
                    }
                    div_alert_buttons.appendChild(div_bt);
                }
                div_alert_background.style.display = 'block';
            }


            function clear_children(e) {
                while (e.hasChildNodes()) {
                    e.removeChild(e.lastChild);
                }
            }


            input_search.oninput = function() {
                
            }



            load_from_storage(storage_path, last_selected_word);

            window.onbeforeunload = function (e) {
                if (current_entry) {
                    settings.set('last_selected_word', current_entry.word);
                }
            }

        </script>

    </body>
</html>
